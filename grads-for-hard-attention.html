<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<link rel = 'stylesheet' href = 'https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.1/css/materialize.min.css'>
<script src = 'https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.1/js/materialize.min.js'></script>
<link href = 'https://fonts.googleapis.com/icon?family=Material+Icons' rel = 'stylesheet'>

<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=DM+Sans&display=swap" rel="stylesheet">

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

<link href="https://fonts.googleapis.com/css2?family=DM+Serif+Text&display=swap" rel="stylesheet">

<style>
    #banner-title {
        font-family:"europa";
    }

    body {
        font-family: "DM Mono"
    }

    a {
        -webkit-transition: all .5s ease;
        -moz-transitition: all .5s ease;
        -o-transition: all .5s ease;
        transition: all .5s ease;

        color: rgb(10, 100, 240);
        border-bottom-color: rgb(240, 240, 240);
        border-bottom-style: solid;
    }

    a:hover {
        border-bottom-color: rgb(50, 100, 240);
    }

    .eq {
        width: 700px;
        text-align:center;
        margin-top:20px;

    }

    .prettyprint {
        font-size:12px;
    }

    .button-a{
         transition:0.2s all ease;
        -webkit-transition:0.2s all ease;
        -moz-transition:all 0.2s ease;
        -o-transition:all 0.2s ease;

        background-color: rgba(0, 0, 0, 0);
        color:white
    }

    .button-a:hover{
        background-color: rgba(255, 255, 255, .2);
        color:white;
    }

    .header {
        font-size: 25px;
        margin-bottom: 10px;
        
    }

    #content {
        margin-left:200px;
        margin-top:50px;
        font-family: "Georgia", "Segoe UI", "Lato";
        font-size: 20px;
        line-height:1.7em;
        font-weight: 300;
    }

    .text {
        width: 700px;
    }

    .img {
        text-align: center;
        width: 250px; 
        position: absolute;
        top: 0;
        left: 775px;
    }

    .image {
        width: 100%;
    }


    @media only screen and (max-width: 1400px) {
        #content {
            margin-left: 10rem;
            font-size: 19px;
        }

        .text {
            width: 50vw;
            min-width: 500px;
        }

        .img {
            left: 55vw;
        }
    }

    @media only screen and (max-width: 1000px) {
        #content {
            margin-left: 10vw;
            width: 80vw;

            font-size: 18px;
        }

        .text {
            min-width: initial;
            width: 80vw;
            font-size: 18px;
        }

        .img {
            width: 80vw;
            text-align: center;
            position: initial;
        }

        .image {
            margin-top: 30px;
            width: 80%;
        }

        .eq {
            width: 100%;
        }
    }

   
</style>

<head><meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<html>
    <body style = ''>

        <div id = 'content' class = '' style = ''>
            <div style = 'font-size: 40px; line-height: 50px; margin-bottom: 20px; margin-top: 100px' class = 'header text'>Pseudo-gradients for hard attention</div>
            <div style = 'font-size: 20px; margin-bottom: 100px; font-family:"DM Mono"; color: gray' class = ' text'>April 21, 2020 Â· <a href = 'https://github.com/nathan-yan/fractals' style = 'margin-bottom: 100px'>Link to repo</a></div>

            <div style = 'line-height:35px' class = 'header text'>
                Soft attention is the more common route for attention because it can be trained using gradient descent, rather than slower and more fragile methods like policy gradients. What if we could produce useful gradients from a hard attention mechanism, so it can be trained using SGD?
            <br/><br/>

            </div>


            <div class = 'header'>
                Backpropagation recap
            </div>

            <div style = 'position: relative'>
                <div class = 'text'>
                    A fractal is a type of abstract geometric object that contains segments which are usually copies of the original. This property is known as self-similarity. One well known fractal which exhibits this behavior perfectly is the <a href = 'https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle'>Sierpinski triangle</a>
                    <br/><br/>
                    Fractals are also typically characterized by "infinite detail", which means they can be zoomed into infinitely without any loss of intricacy. Fractals are known for their appearances in all kinds of places you wouldn't expect, including the coastlines of countries, the waves of oceans, and even in antenna design. One other interesting property of fractals is that they typically exhibit non-integer dimensionality, because of their self-similarity.
                </div>
                <div class = 'img' >
                    <img src = './fractals/sierpinski.png' class = 'image'>
                    <br/>
                    <div style = ' font-size: 15px;'>The Sierpinski Triangle</div>
                </div>
            </div>

            <br/>
            <br/>

            <div class = 'header'>
                The Mandelbrot Set
            </div>

            
            <div style = 'position: relative'>
                <div class = 'text'>
                    The generation process of the Mandelbrot set is pretty simple. We start with a recursive function \(z_{t + 1} = z_{t}^2 + c\). As our base case, \(z_{0} = 0\). To plot the Mandelbrot set, each point on the complex coordinate plane is considered separately, and is the value of \(c\). 
                </div>
            
                <div class = 'img'>
                    <img src = './fractals/mandelbrot.png' class = 'image'>
                    <br/>
                    <div style = ' font-size: 15px;'>The Mandelbrot set</div>
                </div>
            </div>
            
            <div class = 'text'>
                <br/>
                For a quick refresher on the complex plane, \(i\) is the imaginary number, and satisfies the property that \(i^2 = -1\). Points on the complex plane are called complex numbers. To convert a real-valued coordinate to a complex number, you take the x-coordinate (the real part) and add it to the y-coordinate (the imaginary part) multiplied by \(i\).

                For example, the point (3, 2) in the real plane is \(3 + 2i\). Complex numbers also have a magnitude, which is just their distance from the origin. It's very simple to compute--just convert the complex number back into a real point--and calculate its distance from the origin with \(\sqrt{x^2 + y^2}\).
                <br/>
                <br/>
                To generate the Mandelbrot set, we look at all points on the complex plane. For each of these points, we evaluate the recursive function, plugging in the point as \(c\) and \(0\) for \(z_0\). We evaluate the recursive function for some number of iterations \(t\), and at time \(t\) we see if \(z_{t}\) has a magnitude above some threshold. If it is above the threshold, we paint the point white, otherwise we paint it black. In other words, if the value of \(z_{t}\) grows unbounded for a given \(c\), the point on the complex plane \(c\) is colored white, otherwise it is colored black. 
                <br/>
                <br/>
                For the sake of realistic generation, we won't actually look at all points on the complex plane. Our view will be bounded, with both our imaginary and real axes typically within the range \([-1, 1]\) (there isn't much to see beyond that region).
            </div>

            <br/><br/>

            <div class = 'header'>
                Fractal generation
            </div>


            <div class = 'text'>
                Different equations yield different kinds of fractals, and there are all kinds of different things you can try. The point of this project is to use a randomly generated "neural network" as a function (as a disclaimer, it's not really a neural network, because it doesn't try to solve a particular task. However, it does share many of the same aspects, like matrix multiplication and non-linearities) rather than a hand crafted one. Basically, what we're doing is turning our function.
            </div>
            <div class = 'eq'>
                \(z_{t + 1} = z_{t}^2 + c\)
            </div>
            <div>
                into
            </div>
            <div class = 'eq'>
                \(z_{t + 1} = f_{nn}(z_{t}, c)\)
            </div>
            <br/>
            <div style = 'position: relative'>
                <div class = 'text'>
                    where \(f_{nn}\) is a neural network. The neural network I use in the code has two hidden layers each with 10 hidden nodes. The network has two inputs, one for \(z_t\) and one for \(c\). The output of the network is \(z_{t + 1}\). The weights of the network are also complex numbers, with both the real and imaginary components of the weights initialized with a gaussian distribution. The threshold   I used was \(0.8\), and I evaluated the neural network for 30 iterations. On my first attempt, I got the photo on the right:
                </div>
                <div class = 'img'>
                    <img src = './fractals/fractal1_.png' class = 'image'>
                    <br/>
                    <div style = ' font-size: 15px;'>Way cooler than I expected</div>
                </div>
            </div>

            <br/>

            <div style = 'position: relative;'>
                <div class = 'text'>
                    Way cooler than I expected. I then changed the program slightly so that instead of coloring a pixel black or white based on whether or not its value is greater than the threshold, it's colored based on how many iterations it took to exceed the threshold. This gets us an image that less grainy and shows how <i>quickly</i> a point grows unbounded:

                    <br/><br/>

                    The fractal looks different because network weights were initialized at random. I later started recording the seeds (unfortunately I was pretty disorganized while making this, and I don't really know if the seeds correspond to their original images :/ )
                </div>

                <div  class = 'img' style = 'top: inherit; bottom: 0px'>
                    <img src = './fractals/fractal2_.png' class = 'image'>
                    <br/>
                    <div style = 'font-size: 15px;'>Smoothed version</div>
            
                </div>   
            </div>

            <div class = 'text'>
            </div>

            <br/>
            <br/>

            
            <div class = 'header'>
                Specifics
            </div>

            <div class = 'text'>
                I created three variables: \(c, z, \) and a heatmap which I'll call \(h\). \(c\) and \(z\) represent the variables of the recursive function mentioned before. The heatmap is the fractal image and is what is actually plotted. \(c, z, h\) are parameterized by 5 values, which are \(x_{min}, x_{max}, y_{min}, y_{max}, s\). The first four define the lower and upper bounds of the complex plane we'll plot, and \(s\) represents the step, or resolution.

                <div style = 'display: flex; justify-content: center'>
                <pre style = 'width: fit-content'>
import numpy as np
x = np.arange(x_min, x_max, s)
y = np.arange(x_min, x_max, s)

gx, gy = np.meshgrid(x, y)

c = (gx * 1j + gy).flatten()
z = np.zeros(len(c))    
h = np.zeros_like(z)   
                </pre>
                </div>
                Next I define my model using a set of weights and non-linearities. The weights are initialized by sampling small numbers from a zero-mean gaussian distribution for both the real and imaginary component. I created a number of models that produced interesting results, so I'll just show one of them here:
                <div style = 'display: flex; justify-content: center'>

                <pre>
weight1 = 0.2 * randn(2, 10) * 1j + 0.2 * randn(2, 10)
weight2 = 0.35 * randn(10, 10) * 1j + 0.35 * randn(10, 10)
weight3 = 0.45 * randn(10, 1) * 1j + 0.45 * randn(10, 1)

def model(inp):
    fc1 = (inp @ weight1) ** np.sqrt(2)
    fc2 = np.tan((fc1 @ weight2))
    fc3 = fc2 @ weight3

    return fc3
                </pre>
                </div> 

                Since neural networks are basically just matrix multiplication, I don't have to loop through each of the values of \(c\) and \(z\) and compute the recursive function, I can do it all at once! Right now both \(c\) and \(z\) are flattened arrays of some length \(L\). I add an extra dimension to both of them, making them shape \(L \times 1\), then concatenate along the new axis to produce an array of shape \(L \times 2\). Feeding this into the model produces an output of shape \(L \times 1\). To convert this output back into a fully flattened array we just do some simple array slicing. Once the new \(z\) array is calculated, I check whether each value of the array is greater than the threshold 0.8. This whole process is done in a for loop 30 times.

                <div style = 'display: flex; justify-content: center'>

                <pre>
for iteration in range (30):
    c_ = np.expand_dims(c, -1)
    z_ = np.expand_dims(z, -1)

    inp = np.concatenate([c_, z_], axis = -1)

    # compute z{t + 1}
    z = model(inp)[:, 0]

    h += np.absolute(z) > 0.8
                </pre>
                </div>
                At the end \(h\) is a heatmap showing which points went above the threshold the fastest. This can be directly plotted using matplotlib, or any other plotting library.

                 <div style = 'display: flex; justify-content: center'>

                <pre>
import matplotlib.pyplot as plt
plt.imshow(h)
plt.show()
                </pre>
                </div>
            </div>

            <br/><br/>

            <div class = 'header'>
                Gallery
            </div>

                <div class= 'text'>
                Feel free to do whatever you want with these. You can view full resolution images at <a href = "https://github.com/nathan-yan/fractals/tree/master/fractals">the github repo</a> 
                <br/><br/>
            </div>

        </div>

        <div style = 'display: flex; flex-wrap: wrap'>
            <div style = 'width: 80%; margin-left: 10%; align-items:flex-end;'>
                <img src = './fractals/fractal1_.png' style = 'width:48.5%'>
                <img src = './fractals/fractal2_.png' style = 'width:48.5%;'>
                <img src = './fractals/fractal3_.png' style = 'width:48.5%'>
                <img src = './fractals/fractal4_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal5_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal6_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal7_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal9_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal10_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal11_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal12_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal13_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal14_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal15_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal16_.png' style = 'width: 48.5%'>
                <img src = './fractals/fractal17_.png' style = 'width: 48.5%'>        
                <img src = './fractals/fractal8_.png' style = 'width: 100%'>

            </div>
        </div>

        <div style = 'height:50px; width:1px'></div>
    </body>
</html>

<script>

$(document).ready(function(){
      $('.parallax').parallax();
    });

check_resize()

window.addEventListener("resize", check_resize);
</script>
